### Una Piattaforma di Nuova Generazione per i Contratti Intelligenti e le Applicazioni Decentralizzate

Quando Satoshi Nakamoto attivò per primo, nel Gennaio 2009, la blockchain del Bitcoin, stava introducendo due concetti radicali e altamente non testati fino ad allora. Il primo è il "bitcoin", una moneta online peer-to-peer decentralizzata che mantiene un valore senza nessun supporto, [valore intrinseco](http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/) o emittente centrale. Finora, il "Bitcoin" come unità monetaria ha catturato la maggior parte dell'attenzione del pubblico, sia in termini di aspetti politici di una moneta senza una banca centrale che per l' estrema volatilità del prezzo verso l'alto e verso il basso. Comunque c'è anche un'altra, ugualmente importante, parte del grandioso esperimento di Satoshi: il concetto di una blockchain basata sul  proof-of-work che permette un consenso pubblico sul sistema delle transazioni. Il Bitcoin come un'applicazione può essere descritto come un sistema first-to-file: se un'entità ha 50 BTC, e simultaneamente invia gli stessi 50 BTC ad A e a B, solamente la transazione che viene confermata per prima sarà processata. Non c'è nessun intrinseco modo di determinare quale delle due transazioni è avvenuta prima, e per decenni questo ha ostacolato lo sviluppo delle monete digitali decentralizzate. La blockchain di Satoshi era la prima soluzione decentralizzata. Ed ora, l'attenzione sta iniziando rapidamente a spostarsi verso questa seconda parte della tecnologia Bitcoin, e come il concetto di blockchain possa essere utilizzato per qualcosa di più che il denaro.

Le Applicazioni generalmente citate includono l'utilizzo di risorse digitali sulla blockchain per rappresentare valute personalizzate e strumenti finanziari (["monete colorate"](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)), la proprietà di un dispositivo fisico sottostante (["proprietà intelligente"](htups://en.bitcoin.it/wiki/Smart_Property)), assets non fungibili, quali nomi di dominio ("Namecoin") così come le più avanzate applicazioni tipo un exchange decentrallizzato, derivati finanziari, il gioco d'azzardo peer-to-peer ed il sistema di identità e di reputazione sulla blockchain. Un'altra importante area di indagine sono i "contratti intelligenti" - sistemi che automaticamente trasferiscono assets digitali in accordo con regole pre-specificate. Per esempio, si potrebbe avere un contratto di tesoreria nella forma "A può trasferire a X alcune unità di moneta al giorno, B può trasferire a Y alcune unità di moneta al giorno, A e B insieme non possono trasferire niente, ed A può precludere l' "abilità di trasferire" di B. La logica estensione di questo è [organizzazioni autonome decentralizzate](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/) (DAOs) - contratti intelligenti a lungo termine che gestiscono assets e codificano lo statuto di un'intera organizzazione. Quello che Ethereum intende garantire è una blockchain con una linguaggio di programmazione di Turing, completo e costruito al suo interno, che può essere usato per creare "contratti" e per codificare le funzioni arbitrarie di transizione, permettendo agli utenti di creare uno dei sistemi sopra descritti, così come molti altri che non abbiamo ancora immaginato, semplicemente scrivendo la logica in poche righe di codice.

### Tavola dei Contenuti

* [Storia](#history)
    * [Bitcoin come un Sitema di Transizione di Stato](#bitcoin-as-a-state-transition-system)
    * [Mining](#mining)
    * [Merkle Trees](#merkle-trees)
    * [Applicazioni Alternative della blockchain](#alternative-blockchain-applications)
    * [Scripting](#scripting)
* [Ethereum](#ethereum)
    * [Portafogli Ethereum](#ethereum-accounts)
    * [Messaggi e Transazioni](#messages-and-transactions)
    * [Ethereum come un Sitema di Transizione di Stato](#ethereum-state-transition-function)
    * [Esecuzione del Codice](#code-execution)
    * [Blockchain e Mining](#blockchain-and-mining)
* [Applicazioni](#applications)
    * [Sistemi di Prova](#token-systems)
    * [Derivati Finanziari](#financial-derivatives-and-stable-value-currencies)
    * [Sistema di Identità e Reputazione](#identity-and-reputation-systems)
    * [Storage Decentralizzata dei File](#decentralized-file-storage)
    * [Organizzazioni Decentralizzate Autonome](#decentralized-autonomous-organizations)
    * [Ulteriori Applicazioni](#further-applications)
* [Miscellanea e Relazioni](#miscellanea-and-concerns)
    * [Implementazione GHOST Modificata](#modified-ghost-implementation)
    * [Commissioni](#fees)
    * [Calcolo e Completezza di Turing](#computation-and-turing-completeness)
    * [Moneta ed Emissione](#currency-and-issuance)
    * [Centralizzazione del Mining](#mining-centralization)
    * [Scalabilità](#scalability)
* [Conclusione](#conclusion)
* [Referenze ed Ulteriori Letture](#references-and-further-reading)

## Introduzione al Bitcoin ed ai Concetti Esistenti

### Storia

Da decenni sta circolando l'idea di una moneta digitale decentralizzata, così come delle applicazioni alternative come i registri di proprietà. I protocolli anonimi di moneta digitale degli anni '80 e degli anni '90, dipendenti soprattutto su una crittografia primitiva conosciuta come Chaumian blinding, furono forniti da una moneta con un alto tasso di privacy, tuttavia i suddetti protocolli fallirono principalmente per non essere riusciti a guadagnare terreno a causa della loro dipendenza da un intermediario centralizzato. Nel 1998, Wei Dai's [b-money](http://www.weidai.com/bmoney.txt) divenne il primo progetto per l'introduzione dell'idea di creare moneta attraverso la soluzione di puzzle computazionali così come il consenso decentralizzato, ma il progetto era scarno di dettagli su come questo consenso decentralizzato potesse essere concretamente attualizzato. Nel 2005, Hal Finney introdusse il concetto del "[proofs of work riutilizzabile](http://www.finney.org/~hal/rpow/)", un sistema che utilizza le idee provenienti dalla b-moneta insieme ai puzzle computazionali Hashcash di Adam Back per creare un concetto di criptomoneta, ma ancora una volta non riuscii ad ottenere l'idea perché si basava su un calcolo computazionale garantito come backend.

Poichè la moneta è un'applicazione first-to-file, dove l'ordine delle transazioni è spesso di cruciale importanza, monete decentralizzate richiedono una soluzione al consenso decentralizzato. L'ostacolo principale che tutti i protocolli di valuta pre-Bitcoin hanno affrontato consiste nel fatto che, mentre c'era stata moltissima ricerca, per molti anni, sulla creazione di un consenso Byzantine-fault-tolerant condiviso da più parti, dove tutti i protocolli descritti in precedenza risolvevano soltanto la metà del problema. I protocolli supponevano che nel sistema fosse conosciuto, e prodotto margini di sicurezza della forma "se N parti partecipano, poi il sistema può tollerare fino a  N/4 cattivi attori". Tuttavia il problema è che in una regolazione anonima i margini di sicurezza sono vulnerabili da attacchi sibilla, dove un singolo attaccante può creare migliaia di nodi simulati su un server o su una botnet ed usare questi nodi per assicurarsi una quota di maggioranza.

L'innovazione fornita da Satoshi è l'idea di riuscire a combinare un protocollo molto semplice di consenso decentralizzato, basato su dei nodi su cui avvengono le transazioni, che creano una sempre più crescente blockchain attraverso la creazione di "blocchi" ogni 10 minuti, con il proof of work come meccanimso attraverso cui i nodi guadagnano il diritto di partecipare al sistema. Mentre i nodi con una grande quantità di potenza di calcolo hanno proporzionalmente maggiore influenza, raggiungere più potenza computazionale rispetto l'intero network è più difficile rispetto al simulare milioni di nodi. Nonostante la crudezza e la semplicità del modello blockchain del Bitcoin, esso ha dimostrato di essere abbastanza valido, e nel corso dei successivi cinque anni sarebbe diventato il fondamento di oltre duecento monete e protocolli di tutto il mondo.

### Il Bitcoin come un Sistema di Transizione di Stato

![statetransition.png](http://vitalik.ca/files/statetransition.png?2)

Da un punto di vista tecnico, il libro mastro del Bitcoin può essere pensato come un sistema di transizione di stato, dove c'è uno "stato" consistente nella proprietà dello status di tutti i bitcoins esistenti e "la funzione di transizione di stato" che riceve uno stato ed una transizione e trasmette un nuovo stato che ne costituisce il risultato. Nel sistema bancario tradizionale, per esempio, lo stato è il documento costituente il saldo, una transazione è una richiesta di movimentare $X da A a B, e la funzione di transizione di stato sottrae un valore nel conto corrente di A equivalente $X ed incrementa il valore di $X nel conto corrente bancario di B. Se nel conto corrente di A ci sono meno che $X nel primo posto, la funzione di transizione di stato segnala un errore. Quindi, si può formalmente definire:

    APPLY(S,TX) -> S' or ERROR

Nel sistema bancario definito in precedenza:

    APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }

Ma:
    
    APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR

Lo "stato" nel Bitcoin è la raccolta di tutte le monete (tecnicamente, "transazioni in uscita non spese" oUTXO) che sono state effettuate ma non ancora spese, con ogni UTXO che ha una denomoninazione ed un proprietario (definito da un indirizzo da 20-byte che è essenzialmente una chiave crittografica pubblica<sup>[1]</sup>). Una transazione contiene uno o più inputs, con ogni input che contiente un riferimento ad un UTXO esistente ed una firma crittografica prodotta da una chiave privata associata all'indirizzo del proprietario, ed uno o più outputs, con ogni outpout contenente un nuovo UTXO che deve essere aggiunto allo stato.

1. Per ogni input in `TX`:
    * Se il riferimento UTXO non è in `S`, si ha un errore.
    * Se la firma provvista non combacia con il proprietario del UTXO, si ha un errore.
2. Se la somma dei valori di tutti gli input UTXO è inferiore alla somma dei valori di tutti gli outpout UTXO, si ha un errore.
3. Si ha `S` con tutti gli input UTXO meno tutti gli outpout UTXO aggiunti.

La prima metà del primo step previene che ai mittenti delle transazioni di spendere monete che non esistono, la seconda metà del primo step previene ai mittenti delle transazioni di spendere monete di altre persone, ed il secondo step fa rispettare la conservazione del valore. Al fine di utilizzare questo per il pagamento, il protocollo è il seguente. Supponiamo che Alice vuole inviare 11.7 BTC a Bob. Per primo, Alice guarderà per un set di UTXO che lei possiede che ammonta fino ad almeno 11.7 BTC. Realisticamente, Alice non sarà in grado di ottenere esattamente 11.7 BTC; si può dire che il valore più piccolo che può ottenere è 6+4+2=12. Lei poi crea una transazione con quei tre inputs ed i due outputs. Il primo output sarà 11.7 BTC con l'indirizzo che appartiene a Bob, ed il secondo output sarà il rimanente 0.3 BTC "scambiato", con il proprietario essendo Alice stessa.

### Mining

![block_picture.jpg](http://vitalik.ca/files/block_picture.png)

Se abbiamo avuto accesso a un servizio centralizzato di fiducia, questo sistema potrebbe essere banale da implementare; esso potrebbe essere codificato esattamente come descritto. Tuttavia, con i Bitcoin noi abbiamo provato a costruire un sistema monetario, così noi avremo bisogno di combinare il sistema di transizione di stato con un sistema di consenso al fine di assicurare che ognuno è d'accordo sull'ordine delle transazioni. Il processo di consenso decentralizzato del Bitcoin richiede nodi nel network che continuamente tetentano di produrre pacchetti di transazioni chiamati "blocchi". Il network è destinato a produrre all'incirca un blocco ogni dieci minuti, con ogni blocco che contiene una marca temporale, un numero, un riferimento a (ad esempio l'hash del) precedente blocco e una lista di tutte le transazione che sono avvenute dal precedente blocco. Con il passare del tempo, questo crea una persistente, sempre crescente, "blockchain" che si aggiorna costantemente per rappresentare l'ultimo stato del libro mastro del Bitcoin.

L'algoritmo per controllare la validità di un blocco, espresso in questo paradigma, è il seguente:

1. Controllo se il blocco precedente esiste ed è valido.
2. Controllo se la marca temporale del blocco è più grande del blocco precedente<sup>[2]</sup> ed è inferiore di 2 ore nel futuro.
3. Controllo se il proof of work sul blocco è valido.
4. Sia `S[0]` lo stato alla fine del blocco precedente.
5. Si supponga `TX` la lista della transazione del blocco con `n` transazioni. Per tutti `i` in `0...n-1`, sia impostato `S[i+1] = APPLY(S[i],TX[i])` Se da qualsiasi applicazione risulti un errore, esce e ritorna falso.
6. Ritorna vero, e registra `S[n]` come uno stato alla fine del blocco.

Essenzialmente, ogni transazione del blocco deve fornire uno transazione di stato che sia valida. Sia abbia nota che ogni stato non è codificato nel blocco in qualsia modo; esso è puramente una astrazione da ricordare per la validazione del nodo e può essere solo essere (in modo sicuro) computata per qualsiasi nodo iniziando dallo stato di genesi e applicata sequenzialmente ad ogni transazione in ogni nodo. Si abbia nota che è importante l'ordine nel quale ogni miner include le transazioni nel blocco; se ci sono due transazioni A e B nel blocco tale che B impiega una UTXO creata da A, poi il blocco sarà validato se A viene prima di  B ma non viceversa.

La parte interessante dell'algoritmo di validazione del blocco è il concetto di "proof of work": la premessa è che l'hash SHA256 di ogni blocco, costituito come un numero di 256-bit, deve essere inferiore di un target regolato dinamicamente, che è al tempo di questo scritto approssimativamente 2<sup>192</sup>. Lo scopo di questo è di rendere computazionalmente "difficile" la creazione di un blocco, prevenendo con ciò agli attacchi sibilla dal ricreare l'intera blockchain a loro favore. Poichè SHA256 è progettato per essere una funzione completamente imprevedibile e pseudo-randomica, l'unico modo di creare un blocco valido è semplicemente prova ed errore, con l'incremento ripetuto del numero controllando se il nuovo hash corrisponde. Al target corrente di 2<sup>192</sup>, questo significa un media di 2<sup>64</sup> tentativi; in generale, il target è ricalibrato dal network ogni 2016 blocchi in modo che una media di un nuovo blocco è prodotto da qualche nodo nel network ogni dieci minuti. Nella prospettiva di compensare i miners per questo lavoro computazionale, ogni dieci minuti il miner è autorizzato ad includere una transazione donando a se stesso 25 BTC da nulla. In aggiunta, se qualhe transazione ha un valore totale denominale più alto nei suoi inputs che ne suoi outputs, la differenza va al miner come "commissione di transazione". Incidentalmente, questo è pure l'unico meccanismo attraverso cui avviene l'emissione dei BTC; in assoluto lo stato di genesi non contiene alcuna moneta.

Nella prospettiva di una migliore comprensione dello scopo del mining, esaminiamo il caso in cui avvenga un attacco criminoso. Visto che la crittografia implicita nel Bitcoin è conosciuta per essere sicura, l'attaccante colpirà l'unica parte del sistema del Bitcoin che non è protetta direttamente dalla crittografia: l'ordine delle transazioni. La strategia dell'attaccante è semplice:

1. Invio 100 BTC ad un commerciante in cambio di qualche prodotto (preferibilmente un bene digitale consegnabile rapidamente)
2. Attesa per la consegna del prodotto
3. Produzione di un'altra transazione che invia 100 BTC a se stesso
4. Tentativo di convincere il network che la sua transazione a se stesso era quella che è avvenuta per prima.

Una volta avvenuto lo step (1), dopo qualche minuto qualche miner includerà la transazione nel blocco, ad esempio il blocco numero 270000. Dopo circa un'ora, cinque o più blocchi saranno aggiunti alla chain dopo quel blocco, con ognuno di questi blocchi che indirettamente indicano la transazione e quindi la "confermano". A questo punto, il commerciante accetterà il pagamento come finalizzato e consegnerà il prodotto; considerato che stiamo assumendo che questo sia un bene digitale, consegnato in un istante. Adesso, l'attaccante crea un'altra transazione inviando i 100 BTC a se stesso. Se l'attaccante semplicemente rilascia questa in libertà, la transazione non sarà processato; i miners proveranno ad eseguire `APPLY(S,TX)` e prendere nota che `TX` consuma un UTXO che non è più nello stato. Invece in questo modo, l'attaccante crea una "fork" della blockchain, iniziando a minare un'altra versione del blocco 270000 indirizzando il blocco 269999 come una antecedente ma con una nuova transazione che prende il posto di quella vecchia. Poichè i dati del blocco sono differenti, questo richiede il rifacimento della "proof-of-work". Inoltre, la nuova bersione del blocco 270000 dell'attaccante ha un hash differente, così i blocchi originali da 270001 a 270005 non "portano" a quello; quindi, la chain originale e la nuova chain dell'attaccante saranno completamente separate. La regola è che in una fork la blockchain più lunga è considerata essere quella vera, e così i legittimi minatori lavoreranno sulla chain del 270005 mentre l'attaccante da solo sta lavorando sulla chain del 270000. Affinché l'attaccante crei la blockchain più lunga, egli dovrebbe avere più potenza computazionale che il resto del network per ottenere (da quel momento, "51% attacco").

### Merkle Trees

![SPV in bitcoin](https://www.ethereum.org/gh_wiki/spv_bitcoin.png)

_Sinistra: è sufficiente mostrare solo un esiguo numero di nodi in un Merkle tree per dimostrare la prova della validità di un ramo._

_Destra: qualunque tentativo di modificare qualsiasi parte del Merkle tree porterà ad un'incongruenza da qualche parte a monte della chain._

Un'importante funzione della scalabilità del Bitcoin è che nel blocco è memorizzata una struttura di dati multi-livello. L' "hash" di un blocco è in realtà solo l'hash dell'intestazione del blocco, approssimativamente 200-byte di dati che contengono la marca temporale, un numero, hash del precedente blocco e l'hash principale della struttura dei dati chiamata Merkle tree che contiene tutte le transazioni del blocco. Un Merkle tree è un tipo di struttura binaria, composto da un set di nodi con un grande numero di nodi dipendenti alla base della struttura che contengono dati sottostanti, un insieme di nodi intermedi dove ogni nodo è l'hash dei suoi due figli, e alla fine un nodo singolo principale, anch'esso composto dall'hash dei suoi due figli, che rappresenta il "top" della struttura. La finalità del Merkle tree è quello di consentire che i dati in un blocco siano consegnati in maniera frammentaria: un nodo può scaricare solo l'intestazione di un blocco da una sorgente, la piccola parte della struttura di loro interesse da un'altra sorgente, per assicurarsi che tutti i dati siano correnti. Il motivo per cui questo funziona è che gli hash si propagano verso l'alto: se un cattivo utente tenta di cambiare una transazione falsa verso il punto più basso del Merkle tree, questo cambiamento causerà un cambio sul nodo di sopra, e poi un cambio sul nodo sopra quest'ultimo, per cambiare in fine la struttura principal end pertanto l' hash del blocco, causando che il protocollo registri questo come un blocco completamente differente (quasi certamente con un proof of work invalido).

Il protocollo Merkle tree è senza dubbio essenziale per la sostenibilità a lungo termine. Un "nodo completo" nel Bitcoin network, uno che memorizza ed elabora l'interezza di ogni blocco, richiede all'incirca 15 GB di spazio sul disco nel Bitcoin network alla data di Aprile 2014, e sta crescendo di oltre un gigabyte al mese. Allo stato attuale, questo è sostenibile per un computer desktop e non per i telefoni, e più in là con il tempo potranno partecipare solo le aziende e gli appassionati. Un protocollo conosciuto come "controllo semplificato del pagamento" (CSP) permette ad un'altra classe di nodi di esistere, chiamati "nodi leggeri", che scaricano le intestazioni del blocco, verificando la proof of work sulle intestazioni del blocco, e successivamente scaricano solo i  "rami" associati con le transazioni che sono per loro rilevanti. Questo permette ai nodi leggeri di determinare con una forte garanzia di sicurezza quale sia lo status di una qualsiasi transazione Bicoin, ed il loro corrente bilancio, con soltanto il download di una piccolissima parte dell'intera.

### Applicazioni Alternative della Blockchain

L'idea di prendere spunto dalla tecnologia sottostate alla blockchain e di applicarla anche ad altri concetti ha una storia. Nel 2005, Nick Szabo proposte il concetto di "[titoli di proprietà sicuri con l'autorizzazione del proprietario](http://szabo.best.vwh.net/securetitle.html)", un documento che descriveva come "nuovi progressi nella tecnologia di un database replicato" consentiranno ad un sistema basato sulla blockchain di conservare un registro di chi possiede quella terra, creando un quadro elaborato che include concetti come quello di autosufficienza economica, usucapione e la tasse sulla terra Georgiana Tuttavia, sfortunatamente non era disponibile a quel tempo un efficace sistema di database replicato, ed il protocollo non fu mai implementato nella pratica. Ciononostante dopo il 2009 una volta che il consenso decentralizzato del Bitcoin fu sviluppato un numero di applicazioni alternative cominciò rapidamente ad emergere.

* **Namecoin** - creato nel 2010, [Namecoin](https://namecoin.org/) conosciuto come un sistema decentralizzato di database per la registrazione di nomi di dominio. Nei protocolli decentralizzati come Tor, Bitcoin e BitMessage, c'è bisogno di un modo di identificare gli account in modo che le altre persone possono interagire con loro, ma in tutte le soluzioni esistenti l'unico tipo di identificatore disponibile è un hash pseudo casuale come `1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy`. Idealmente, qualcuno potrebbe avere un account con un nome come "george". Tuttavia, il problema è che se una persona può creare un account chiamato "george" poi qualcun altro può utilizzare lo stesso processo per registrare "george" per se stesso così come per impersonificare quell'altra persona. L'unica soluzione è il paradigma first-to-file, dove il primo registrante ha successo ed il secondo fallisce - un problema che si adatta perfettamente al protocollo di consenso del Bitcoin. Namecoin è la più vecchia, e di più successo, implementazione di un sistema di registrazione di dominio che utilizza una tale idea.
* **Monete colorate** - lo scopo delle [monete colorate](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit) è quello di servire come un protocollo per consentire alle persone di creare le proprie valute digitali - o, nell'importante caso banale di una moneta con una sola unità, tokens digitali, sulla Blockchain del Bitcoin. Nel protocollo delle monete colorate, una persona "emette" una nuova moneta assegnando pubblicamente un colore ad una UTXO specifica del Bitcoin, e il protocollo definisce ricorsivamente il colore dell'altra UTXO al fine che sia dello stesso colore degli inputs di quella transazione da cui deriva (qualche regola speciale si applica nel caso di inputs di colori di monete misti. Questo permette agli utenti di conservare portafogli di monete che contengono solo una UTXO di uno specifico colore e di inviare questa in modo del tutto simile ai Bitcoins, attraverso lo studio della blockchain per determinare il colore di un qualsiasi UTXO che essi hanno ricevuto.
* **Metacoins** - l'idea dietro un metacoin è quello di avere un protocollo che vive in cima Bitcoin, usando le transazioni Bitcoin per conservare le transazioni metacoin ma avendo una differente funzione di transazione, `APPLY'`. Poichè il protoccolo Metacoin non può prevenire che una transazione metacoin invalida cannot prevent invalid metacoin transactions sia visualizzata sulla blockchain del Bitcoin, si aggiunge una regola che se `APPLY'(S,TX)`ritorna come un errore, le impostazioni predefinite del protocollo sono`APPLY'(S,TX) = S`. Questo fornisce un semplice meccanismo per la creazione di un protocollo arbitrario di criptomoneta, potenzialmente con funzioni avanzate che non possono essere implementate all'interno del Bitcoin stesso, ma con un costo di sviluppo molto basso visto che la complessità del mining e del networking sono già gestiti dal protocollo Bitcoin.

